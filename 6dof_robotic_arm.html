<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Robot Sim + USB (cmd_vel + legacy + E-Stop)</title>
  <style>
    body { margin: 0; overflow: hidden; font-family: sans-serif; }

    #info {
      position: absolute; top: 10px; width: 100%;
      text-align: center; color: #333; pointer-events: none;
      font-weight: bold; text-shadow: 1px 1px 0 #fff;
      background: rgba(255, 255, 255, 0.6); padding: 10px;
    }

    #controls-help {
      position: absolute; bottom: 20px; left: 20px;
      background: rgba(255, 255, 255, 0.9);
      padding: 15px; border-radius: 8px; pointer-events: none;
      font-size: 13px; line-height: 1.6;
      box-shadow: 0 0 10px rgba(0,0,0,0.1);
    }

    #cam-label {
      position: absolute; bottom: 265px; right: 20px;
      color: white; background: #333; padding: 2px 8px;
      font-size: 12px; font-weight: bold;
      border-radius: 3px 3px 0 0;
    }

    .key {
      display: inline-block; border: 1px solid #999;
      background: #eee; border-radius: 3px; padding: 0 5px;
      font-family: monospace; font-weight: bold;
      min-width: 15px; text-align: center;
    }

    .section-title { font-weight: bold; text-decoration: underline; margin-top: 5px; display: block; }

    #json-control {
      position: absolute; top: 10px; left: 10px;
      background: rgba(255,255,255,0.92);
      padding: 10px; border-radius: 10px;
      width: 360px; box-shadow: 0 0 10px rgba(0,0,0,0.12);
      font-size: 12px;
    }

    #row { display: flex; gap: 6px; }
    #row > button { flex: 1; }

    button {
      cursor: pointer;
      border: 1px solid #bbb;
      background: #f7f7f7;
      padding: 8px;
      border-radius: 8px;
      font-size: 12px;
    }
    button:hover { background: #efefef; }

    button.danger { background: #ffe2e2; border-color: #ff9b9b; }
    button.danger:hover { background: #ffd2d2; }

    button.primary { background: #e8f1ff; border-color: #9bbcff; }
    button.primary:hover { background: #dbe9ff; }

    textarea {
      width: 100%;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size: 11px;
      border-radius: 8px;
      border: 1px solid #ccc;
      padding: 8px;
      box-sizing: border-box;
    }

    #serial-status { font-size: 11px; margin-top: 6px; color: #555; line-height: 1.35; }
    #serial-log {
      margin-top: 6px;
      padding: 6px;
      background: rgba(0,0,0,0.03);
      border-radius: 8px;
      border: 1px solid rgba(0,0,0,0.06);
      font-family: ui-monospace, monospace;
      font-size: 10px;
      max-height: 110px;
      overflow: auto;
      white-space: pre-wrap;
    }

    .small { font-size: 11px; color: #666; }
    .pill {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 999px;
      background: rgba(0,0,0,0.06);
      margin-left: 6px;
      font-size: 11px;
    }

    label { user-select: none; }
    .hr { height: 1px; background: rgba(0,0,0,0.1); margin: 8px 0; }

    input[type="checkbox"] { transform: translateY(1px); }
  </style>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
  </script>
</head>

<body>
  <div id="info">
    Robot Sim + USB Control<br />
    <span class="small">Apply-to-Sim supports: cmd_vel + legacy servos/motors. USB supports: mode usb/crsf, cmd_vel, estop.</span>
  </div>

  <div id="controls-help">
    <span class="section-title">Arm (Sim) Keys</span>
    <b>J2 (Shoulder):</b> <span class="key">Q</span>/<span class="key">A</span><br>
    <b>J3 (Elbow):</b> <span class="key">W</span>/<span class="key">S</span><br>
    <b>J5 (Pitch):</b> <span class="key">E</span>/<span class="key">D</span><br>
    <b>Gripper:</b> <span class="key">R</span>/<span class="key">F</span><br>
    <b>J1 (Waist):</b> <span class="key">Y</span>/<span class="key">X</span> (or <span class="key">Z</span>/<span class="key">X</span>)<br>
    <b>J6 (Roll):</b> <span class="key">C</span>/<span class="key">V</span><br>

    <span class="section-title">Base (Sim + optional USB cmd_vel)</span>
    <span class="key">⬆️</span> <span class="key">⬇️</span> <span class="key">⬅️</span> <span class="key">➡️</span>
    <div class="small">If “Live cmd_vel” enabled AND target=USB, arrows also send cmd_vel to Arduino.</div>
  </div>

  <div id="json-control">
    <div style="display:flex; align-items:center; justify-content:space-between;">
      <strong>USB / JSON Control</strong>
      <span id="mode-pill" class="pill">mode: unknown</span>
    </div>

    <div style="margin-top:6px;" id="row">
      <button id="btn-connect" class="primary">Connect</button>
      <button id="btn-usbmode">Set USB Mode</button>
      <button id="btn-crsfmode">Set CRSF Mode</button>
    </div>

    <div class="hr"></div>

    <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
      <label><input type="radio" name="target" value="usb" checked> Send to USB</label>
      <label><input type="radio" name="target" value="sim"> Apply to Sim</label>

      <label title="If enabled, Arrow keys will send cmd_vel to Arduino at 10 Hz while pressed (USB only).">
        <input type="checkbox" id="chk-live-cmdvel" checked> Live cmd_vel
      </label>

      <label title="Hold cmd_vel in SIM (keeps moving until Stop), instead of timing out after ~150ms.">
        <input type="checkbox" id="chk-sim-hold" checked> Hold cmd_vel in SIM
      </label>

      <label title="Invert forward/back for cmd_vel only (does not affect sim arrows).">
        <input type="checkbox" id="chk-invert-v"> Invert V
      </label>
      <label title="Invert turning for cmd_vel only (does not affect sim arrows).">
        <input type="checkbox" id="chk-invert-w"> Invert W
      </label>
    </div>

    <div class="hr"></div>

    <div id="row">
      <button id="btn-stop">Stop</button>
      <button id="btn-estop" class="danger">E-STOP</button>
      <button id="btn-estop-off">E-STOP OFF</button>
    </div>

    <div class="hr"></div>

    <textarea id="json-input" rows="11">{
  "type": "cmd_vel",
  "v": 0.35,
  "w": 0.0
}</textarea>

    <div style="margin-top:6px;" id="row">
      <button id="btn-send" class="primary">Send JSON</button>
      <button id="btn-send-legacy">Send Legacy Example</button>
    </div>

    <div id="serial-status">Not connected. (Web Serial requires https or localhost.)</div>
    <div id="serial-log" aria-label="Serial log"></div>
  </div>

  <div id="cam-label">J5 Wrist Camera</div>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

    // ------------------------------
    // SIM
    // ------------------------------
    const config = {
      jointColor: 0x333333,
      linkColor: 0xFFD700,
      metalColor: 0xAAAAAA,
      gripperColor: 0x222222,
      wheelColor: 0x111111,
      baseColor: 0x444444
    };

    const defaults = { J1: 0, J2: -80, J3: 160, J5: 10, J6: 90, gripper: 0 };
    const params = {
      ...defaults, reset: function () {
        Object.assign(this, defaults);
        Object.assign(targetParams, defaults);
        if (isGrasped) { scene.attach(interactiveCube); isGrasped = false; }
        cubeVelocityY = 0;
        interactiveCube.position.set(3, 0.25, 3);
        interactiveCube.rotation.set(0, 0, 0);
        interactiveCube.material.color.setHex(0x0044ff);
        mobileUnit.position.set(0, 0, 0);
        mobileUnit.rotation.set(0, 0, 0);
        updateJoints();
        gui.controllers.forEach(c => c.updateDisplay());
      }
    };
    const targetParams = { ...defaults };
    let simSpeed = 60;
    const FPS = 60;

    const keys = {};
    const driveStats = { maxSpeed: 0.1, maxRot: 0.04 };
    const motorCmd = { active: false, speed: 0, rot: 0, endTime: 0 };

    const armSpeed = 1.0;
    const gripperSpeed = 2.0;
    let isGrasped = false;
    const GRASP_THRESHOLD = 0.8;
    let cubeVelocityY = 0;
    const GRAVITY = -0.015;
    const FLOOR_LEVEL = 0.25;

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf0f0f0);
    scene.fog = new THREE.Fog(0xf0f0f0, 20, 80);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(8, 8, 10);

    const cameraJ5 = new THREE.PerspectiveCamera(50, 320 / 240, 0.05, 50);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.autoClear = false;
    document.body.appendChild(renderer.domElement);

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);

    const dirLight = new THREE.DirectionalLight(0xffffff, 1);
    dirLight.position.set(10, 20, 10);
    dirLight.castShadow = true;
    dirLight.shadow.mapSize.width = 2048;
    dirLight.shadow.mapSize.height = 2048;
    scene.add(dirLight);

    const gridHelper = new THREE.GridHelper(100, 100, 0x888888, 0xcccccc);
    scene.add(gridHelper);

    const planeGeo = new THREE.PlaneGeometry(100, 100);
    const planeMat = new THREE.MeshLambertMaterial({ color: 0xffffff });
    const plane = new THREE.Mesh(planeGeo, planeMat);
    plane.rotation.x = -Math.PI / 2;
    plane.receiveShadow = true;
    scene.add(plane);

    const cubeGeo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
    const cubeMat = new THREE.MeshPhongMaterial({ color: 0x0044ff });
    const interactiveCube = new THREE.Mesh(cubeGeo, cubeMat);
    interactiveCube.position.set(3, 0.25, 3);
    interactiveCube.castShadow = true;
    interactiveCube.receiveShadow = true;
    scene.add(interactiveCube);

    const targetGeo = new THREE.RingGeometry(0.1, 1.5, 32);
    const targetMat = new THREE.MeshBasicMaterial({ color: 0x008800, side: THREE.DoubleSide, transparent: true, opacity: 0.5 });
    const targetCircle = new THREE.Mesh(targetGeo, targetMat);
    targetCircle.rotation.x = -Math.PI / 2;
    targetCircle.position.set(-4, 0.01, 2);
    scene.add(targetCircle);

    function createMesh(geometry, color) {
      const material = new THREE.MeshPhongMaterial({ color });
      const mesh = new THREE.Mesh(geometry, material);
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      return mesh;
    }

    const mobileUnit = new THREE.Group();
    scene.add(mobileUnit);
    const Z_OFFSET = -1.2;

    const chassis = createMesh(new THREE.BoxGeometry(2.5, 0.5, 3.5), config.baseColor);
    chassis.position.set(0, 0.5, Z_OFFSET); mobileUnit.add(chassis);

    const wheelGeo = new THREE.CylinderGeometry(0.5, 0.5, 0.4, 32).rotateZ(Math.PI / 2);
    const hubGeo = new THREE.CylinderGeometry(0.2, 0.2, 0.42, 16).rotateZ(Math.PI / 2);

    const wFL = createMesh(wheelGeo, config.wheelColor); wFL.position.set(1.4, 0.5, -1.2 + Z_OFFSET); mobileUnit.add(wFL);
    const wFR = createMesh(wheelGeo, config.wheelColor); wFR.position.set(-1.4, 0.5, -1.2 + Z_OFFSET); mobileUnit.add(wFR);
    const wBL = createMesh(wheelGeo, config.wheelColor); wBL.position.set(1.4, 0.5, 1.2 + Z_OFFSET); mobileUnit.add(wBL); wBL.add(createMesh(hubGeo, 0xff0000));
    const wBR = createMesh(wheelGeo, config.wheelColor); wBR.position.set(-1.4, 0.5, 1.2 + Z_OFFSET); mobileUnit.add(wBR); wBR.add(createMesh(hubGeo, 0xff0000));

    const baseMesh = createMesh(new THREE.CylinderGeometry(0.8, 0.8, 0.2, 32), config.jointColor);
    baseMesh.position.set(0, 0.85, Z_OFFSET - 0.7); mobileUnit.add(baseMesh);

    const pivot1 = new THREE.Group(); pivot1.position.y = 0.1; baseMesh.add(pivot1);
    const pivot2 = new THREE.Group(); pivot2.position.y = 0.2; pivot1.add(pivot2);
    pivot2.add(createMesh(new THREE.CylinderGeometry(0.4, 0.4, 0.8, 16).rotateX(Math.PI / 2), config.jointColor));

    const link2 = createMesh(new THREE.BoxGeometry(0.6, 2.5, 0.6), config.linkColor); link2.position.y = 1.25; pivot2.add(link2);
    const pivot3 = new THREE.Group(); pivot3.position.y = 1.25; link2.add(pivot3);
    const link3 = createMesh(new THREE.BoxGeometry(0.5, 2, 0.5), config.linkColor); link3.position.y = 1.0; pivot3.add(link3);

    const pivot5 = new THREE.Group(); pivot5.position.y = 1.0; link3.add(pivot5);
    pivot5.add(createMesh(new THREE.CylinderGeometry(0.35, 0.35, 0.6, 16).rotateX(Math.PI / 2), config.jointColor));
    const link5 = createMesh(new THREE.BoxGeometry(0.4, 0.5, 0.4), config.metalColor); link5.position.y = 0.35; pivot5.add(link5);

    pivot5.add(cameraJ5);
    cameraJ5.position.set(-0.4, 0, 0);
    cameraJ5.rotation.x = Math.PI / 2;
    cameraJ5.rotation.z = -Math.PI / 2;

    const camVis = createMesh(new THREE.BoxGeometry(0.1, 0.1, 0.2), 0x000000);
    camVis.position.set(-0.4, 0, 0);
    camVis.rotation.set(Math.PI / 2, 0, -Math.PI / 2);
    pivot5.add(camVis);

    const pivot6 = new THREE.Group(); pivot6.position.y = 0.5; link5.add(pivot6);
    const flange = createMesh(new THREE.CylinderGeometry(0.3, 0.3, 0.1, 16), 0x333333); flange.position.y = 0.05; pivot6.add(flange);

    const gripperGroup = new THREE.Group(); gripperGroup.position.y = 0.1; flange.add(gripperGroup);
    const gripBase = createMesh(new THREE.BoxGeometry(0.8, 0.2, 0.3), config.gripperColor); gripBase.position.y = 0.1; gripperGroup.add(gripBase);
    const fingerL = createMesh(new THREE.BoxGeometry(0.1, 0.6, 0.3), config.metalColor); fingerL.position.set(-0.2, 0.4, 0); gripBase.add(fingerL);
    const fingerR = createMesh(new THREE.BoxGeometry(0.1, 0.6, 0.3), config.metalColor); fingerR.position.set(0.2, 0.4, 0); gripBase.add(fingerR);
    const graspPoint = new THREE.Object3D(); graspPoint.position.set(0, 0.6, 0); gripBase.add(graspPoint);

    function updateJoints() {
      const rad = (deg) => deg * (Math.PI / 180);
      pivot1.rotation.y = rad(params.J1) - Math.PI / 2;
      pivot2.rotation.z = rad(params.J2);
      pivot3.rotation.z = rad(params.J3);
      pivot5.rotation.z = rad(params.J5);
      pivot6.rotation.y = rad(params.J6);

      const gap = 0.15 + (params.gripper / 100) * 0.25;
      fingerL.position.x = -gap;
      fingerR.position.x = gap;
    }

    function checkGraspLogic() {
      const graspWorldPos = new THREE.Vector3(); graspPoint.getWorldPosition(graspWorldPos);
      const cubeWorldPos = new THREE.Vector3(); interactiveCube.getWorldPosition(cubeWorldPos);

      const isCloseEnough = graspWorldPos.distanceTo(cubeWorldPos) < GRASP_THRESHOLD;
      if (!isGrasped) interactiveCube.material.color.setHex(isCloseEnough ? 0xFFD700 : 0x0044ff);

      if (params.gripper < 10 && !isGrasped && isCloseEnough) {
        gripperGroup.attach(interactiveCube);
        isGrasped = true;
        interactiveCube.material.color.setHex(0x00ff00);
        cubeVelocityY = 0;
      }
      if (params.gripper > 50 && isGrasped) {
        scene.attach(interactiveCube);
        isGrasped = false;
        interactiveCube.material.color.setHex(0x0044ff);
        interactiveCube.rotation.set(0, interactiveCube.rotation.y, 0);
      }
    }

    window.addEventListener('keydown', (e) => { keys[e.key.toLowerCase()] = true; });
    window.addEventListener('keyup', (e) => { keys[e.key.toLowerCase()] = false; });

    const gui = new GUI({ title: 'Sim Controls' });
    const fJoints = gui.addFolder('Arm Angles');
    fJoints.add(params, 'J1', -90, 90).onChange(() => { Object.assign(targetParams, params); updateJoints(); }).listen();
    fJoints.add(params, 'J2', -90, 90).onChange(() => { Object.assign(targetParams, params); updateJoints(); }).listen();
    fJoints.add(params, 'J3', 0, 180).onChange(() => { Object.assign(targetParams, params); updateJoints(); }).listen();
    fJoints.add(params, 'J5', -90, 90).onChange(() => { Object.assign(targetParams, params); updateJoints(); }).listen();
    fJoints.add(params, 'J6', -90, 90).onChange(() => { Object.assign(targetParams, params); updateJoints(); }).listen();
    const fTool = gui.addFolder('End Effector');
    fTool.add(params, 'gripper', 0, 100).name('Gripper Open').listen().onChange(() => { Object.assign(targetParams, params); updateJoints(); });
    gui.add(params, 'reset').name('Reset Task');

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    function clamp(val, min, max) { return Math.min(Math.max(val, min), max); }

    // ------------------------------
    // USB SERIAL
    // ------------------------------
    let port = null;
    let writer = null;
    let reader = null;
    let isConnected = false;

    const btnConnect = document.getElementById('btn-connect');
    const btnSend = document.getElementById('btn-send');
    const btnSendLegacy = document.getElementById('btn-send-legacy');
    const btnUsbMode = document.getElementById('btn-usbmode');
    const btnCrsfMode = document.getElementById('btn-crsfmode');
    const btnStop = document.getElementById('btn-stop');
    const btnEstop = document.getElementById('btn-estop');
    const btnEstopOff = document.getElementById('btn-estop-off');

    const txtInput = document.getElementById('json-input');
    const lblStatus = document.getElementById('serial-status');
    const logBox = document.getElementById('serial-log');
    const modePill = document.getElementById('mode-pill');

    const chkLiveCmdVel = document.getElementById('chk-live-cmdvel');
    const chkSimHold = document.getElementById('chk-sim-hold');
    const chkInvertV = document.getElementById('chk-invert-v');
    const chkInvertW = document.getElementById('chk-invert-w');

    function logLine(line) {
      const maxChars = 6000;
      logBox.textContent = (logBox.textContent + line + "\n").slice(-maxChars);
      logBox.scrollTop = logBox.scrollHeight;
    }

    async function sendObj(obj) {
      if (!writer) {
        alert("Connect via USB first.");
        return;
      }
      await writer.write(JSON.stringify(obj) + "\n");
    }

    function updateStatusUI(text, ok = true) {
      lblStatus.textContent = text;
      lblStatus.style.color = ok ? "#206020" : "#9b2020";
    }

    async function connectSerial() {
      try {
        port = await navigator.serial.requestPort();
        await port.open({ baudRate: 115200 });

        const textEncoder = new TextEncoderStream();
        textEncoder.readable.pipeTo(port.writable);
        writer = textEncoder.writable.getWriter();

        const textDecoder = new TextDecoderStream();
        port.readable.pipeTo(textDecoder.writable);
        reader = textDecoder.readable.getReader();

        isConnected = true;
        btnConnect.disabled = true;

        updateStatusUI("Connected. Switching to USB mode…", true);
        await sendObj({ type: "mode", mode: "usb" });

        readLoop();
        updateStatusUI("Connected (USB mode set).", true);
      } catch (err) {
        console.error(err);
        updateStatusUI("Error: " + err.message, false);
      }
    }

    async function readLoop() {
      let buffer = "";
      try {
        while (isConnected && reader) {
          const { value, done } = await reader.read();
          if (done) break;
          buffer += value;

          let idx;
          while ((idx = buffer.indexOf("\n")) >= 0) {
            const line = buffer.slice(0, idx).trim();
            buffer = buffer.slice(idx + 1);

            if (!line) continue;
            logLine(line);

            try {
              const msg = JSON.parse(line);
              if (msg.mode) modePill.textContent = `mode: ${msg.mode}${msg.estop ? " (ESTOP)" : ""}`;
              if (msg.servos || msg.motors || msg.type === "cmd_vel") applyToSim(msg);
            } catch (_) {}
          }
        }
      } catch (err) {
        console.error("readLoop error:", err);
        updateStatusUI("Serial read error: " + err.message, false);
      }
    }

    // ------------------------------
    // APPLY JSON -> SIM (CORRECT)
    // ------------------------------
    function applyToSim(data) {
      // 1) servos -> arm joints
      if (data.servos) {
        if (data.servos.speed !== undefined) simSpeed = data.servos.speed;
        if (data.servos.waist !== undefined) targetParams.J1 = data.servos.waist;
        if (data.servos.shoulder !== undefined) targetParams.J2 = data.servos.shoulder;
        if (data.servos.elbow !== undefined) targetParams.J3 = data.servos.elbow;
        if (data.servos.wristP !== undefined) targetParams.J5 = data.servos.wristP;
        if (data.servos.wristR !== undefined) targetParams.J6 = data.servos.wristR;
        if (data.servos.gripper !== undefined) targetParams.gripper = data.servos.gripper;
      }

      // 2) motors legacy timed -> base
      if (data.motors) {
        const left = data.motors.left || 0;
        const right = data.motors.right || 0;
        const duration = data.motors.duration || 0;

        if (duration > 0) {
          const avg = (left + right) / 2;
          const diff = (left - right);

          motorCmd.speed = -(avg / 255) * driveStats.maxSpeed;
          motorCmd.rot   = -(diff / 255) * driveStats.maxRot;
          motorCmd.endTime = Date.now() + duration;
          motorCmd.active = true;
        }
      }

      // 3) cmd_vel -> base
      if (data.type === "cmd_vel" || (data.v !== undefined && data.w !== undefined)) {
        const v = Number(data.v ?? 0);
        const w = Number(data.w ?? 0);

        const EXPECT_V_MAX = 0.45;
        const EXPECT_W_MAX = 0.70;

        const vScale = driveStats.maxSpeed / EXPECT_V_MAX;
        const wScale = driveStats.maxRot   / EXPECT_W_MAX;

        motorCmd.speed = -v * vScale; // sim forward is negative in your mapping
        motorCmd.rot   =  w * wScale;

        motorCmd.active = true;

        // Hold behavior:
        // - if Hold enabled, keep "active" indefinitely (by setting far future)
        // - else use short timeout (needs repeated sends)
        motorCmd.endTime = chkSimHold.checked ? (Date.now() + 3600_000) : (Date.now() + 150);
      }
    }

    async function sendJSONFromTextarea() {
      const jsonStr = txtInput.value;
      let data;
      try { data = JSON.parse(jsonStr); }
      catch (err) { alert("Invalid JSON: " + err.message); return; }

      const target = document.querySelector('input[name="target"]:checked').value;
      if (target === "usb") {
        if (!writer) return alert("Connect via USB first.");
        await writer.write(JSON.stringify(data) + "\n");
      } else {
        applyToSim(data);
      }
    }

    async function sendLegacyExample() {
      const legacy = {
        servos: { waist: 45, shoulder: 0, elbow: 90, wristP: 0, wristR: 0, gripper: 50, speed: 60 },
        motors: { left: 120, right: 120, duration: 600 }
      };
      const target = document.querySelector('input[name="target"]:checked').value;
      if (target === "usb") await sendObj(legacy);
      else applyToSim(legacy);
    }

    function stopSimBase() {
      motorCmd.active = false;
      motorCmd.speed = 0;
      motorCmd.rot = 0;
      motorCmd.endTime = 0;
    }

    btnConnect.addEventListener('click', connectSerial);
    btnSend.addEventListener('click', sendJSONFromTextarea);
    btnSendLegacy.addEventListener('click', sendLegacyExample);

    btnUsbMode.addEventListener('click', () => sendObj({ type: "mode", mode: "usb" }));
    btnCrsfMode.addEventListener('click', () => sendObj({ type: "mode", mode: "crsf" }));

    // Stop should work for both targets:
    btnStop.addEventListener('click', async () => {
      const target = document.querySelector('input[name="target"]:checked').value;
      if (target === "usb") {
        if (!writer) return alert("Connect via USB first.");
        await sendObj({ type: "cmd_vel", v: 0, w: 0 });
      } else {
        stopSimBase();
      }
    });

    btnEstop.addEventListener('click', () => sendObj({ type: "estop", enabled: true }));
    btnEstopOff.addEventListener('click', () => sendObj({ type: "estop", enabled: false }));

    // ------------------------------
    // Live cmd_vel from Arrow keys (USB only)
    // ------------------------------
    let liveV = 0.0, liveW = 0.0;
    const LIVE_V = 0.45;
    const LIVE_W = 0.70;
    let cmdVelTimer = null;

    function computeLiveVW() {
      const up = !!keys['arrowup'];
      const down = !!keys['arrowdown'];
      const left = !!keys['arrowleft'];
      const right = !!keys['arrowright'];

      let v = (up ? LIVE_V : 0) + (down ? -LIVE_V : 0);
      let w = (left ? LIVE_W : 0) + (right ? -LIVE_W : 0);

      if (chkInvertV.checked) v = -v;
      if (chkInvertW.checked) w = -w;

      liveV = v; liveW = w;
    }

    async function sendCmdVelOnce() {
      const target = document.querySelector('input[name="target"]:checked').value;
      if (!writer || !isConnected || !chkLiveCmdVel.checked || target !== "usb") return;
      await sendObj({ type: "cmd_vel", v: liveV, w: liveW });
    }

    function startCmdVelLoop() {
      if (cmdVelTimer) return;
      cmdVelTimer = setInterval(() => { sendCmdVelOnce(); }, 100);
    }

    function stopCmdVelLoop() {
      if (!cmdVelTimer) return;
      clearInterval(cmdVelTimer);
      cmdVelTimer = null;
    }

    // ------------------------------
    // Animation loop
    // ------------------------------
    function animate() {
      requestAnimationFrame(animate);

      const step = simSpeed / FPS;
      const moveTowards = (key, min, max) => {
        let curr = params[key];
        let targ = targetParams[key];
        if (Math.abs(curr - targ) > step) params[key] += (targ > curr) ? step : -step;
        else params[key] = targ;
        params[key] = clamp(params[key], min, max);
      };

      moveTowards('J1', -90, 90);
      moveTowards('J2', -90, 90);
      moveTowards('J3', 0, 180);
      moveTowards('J5', -90, 90);
      moveTowards('J6', -90, 90);
      moveTowards('gripper', 0, 100);

      // Arm keys
      if (keys['q']) targetParams.J2 = params.J2 = clamp(params.J2 + armSpeed, -90, 90);
      if (keys['a']) targetParams.J2 = params.J2 = clamp(params.J2 - armSpeed, -90, 90);
      if (keys['w']) targetParams.J3 = params.J3 = clamp(params.J3 + armSpeed, 0, 180);
      if (keys['s']) targetParams.J3 = params.J3 = clamp(params.J3 - armSpeed, 0, 180);
      if (keys['e']) targetParams.J5 = params.J5 = clamp(params.J5 + armSpeed, -90, 90);
      if (keys['d']) targetParams.J5 = params.J5 = clamp(params.J5 - armSpeed, -90, 90);

      if (keys['y'] || keys['z']) targetParams.J1 = params.J1 = clamp(params.J1 + armSpeed, -90, 90);
      if (keys['x']) targetParams.J1 = params.J1 = clamp(params.J1 - armSpeed, -90, 90);

      if (keys['c']) targetParams.J6 = params.J6 = clamp(params.J6 + armSpeed, -90, 90);
      if (keys['v']) targetParams.J6 = params.J6 = clamp(params.J6 - armSpeed, -90, 90);

      if (keys['r']) targetParams.gripper = params.gripper = clamp(params.gripper + gripperSpeed, 0, 100);
      if (keys['f']) targetParams.gripper = params.gripper = clamp(params.gripper - gripperSpeed, 0, 100);

      updateJoints();

      // Base movement
      let speed = 0, rot = 0;

      // motorCmd from JSON (legacy/cmd_vel)
      if (motorCmd.active) {
        if (Date.now() < motorCmd.endTime) {
          speed = motorCmd.speed;
          rot = motorCmd.rot;
        } else {
          motorCmd.active = false;
        }
      }

      // Arrow keys always drive SIM base (independent of JSON)
      if (keys['arrowup']) speed -= driveStats.maxSpeed;
      if (keys['arrowdown']) speed += driveStats.maxSpeed;
      if (keys['arrowleft']) rot += driveStats.maxRot;
      if (keys['arrowright']) rot -= driveStats.maxRot;

      // USB live cmd_vel (only when target=USB)
      computeLiveVW();
      const anyArrow = keys['arrowup'] || keys['arrowdown'] || keys['arrowleft'] || keys['arrowright'];
      const target = document.querySelector('input[name="target"]:checked').value;
      const usbActive = (target === "usb") && chkLiveCmdVel.checked && writer && isConnected;

      if (anyArrow && usbActive) startCmdVelLoop();
      else {
        if (cmdVelTimer) {
          stopCmdVelLoop();
          if (usbActive) sendObj({ type: "cmd_vel", v: 0, w: 0 }).catch(() => {});
        }
      }

      if (speed !== 0 || rot !== 0) {
        mobileUnit.rotation.y += rot;
        mobileUnit.position.addScaledVector(
          new THREE.Vector3(0, 0, 1).applyAxisAngle(new THREE.Vector3(0, 1, 0), mobileUnit.rotation.y),
          speed
        );

        const ws = speed * 2;
        wBL.rotation.x += ws; wBR.rotation.x += ws; wFL.rotation.x += ws; wFR.rotation.x += ws;

        const camT = mobileUnit.position.clone()
          .add(new THREE.Vector3(0, 0, -Z_OFFSET).applyAxisAngle(new THREE.Vector3(0, 1, 0), mobileUnit.rotation.y));
        controls.target.copy(camT); controls.target.y += 2;
      }

      checkGraspLogic();

      if (!isGrasped) {
        cubeVelocityY += GRAVITY;
        interactiveCube.position.y += cubeVelocityY;
        if (interactiveCube.position.y <= FLOOR_LEVEL) {
          interactiveCube.position.y = FLOOR_LEVEL;
          cubeVelocityY = 0;
        }
      }

      if (!isGrasped && interactiveCube.position.y === FLOOR_LEVEL) {
        const d = new THREE.Vector2(interactiveCube.position.x, interactiveCube.position.z)
          .distanceTo(new THREE.Vector2(targetCircle.position.x, targetCircle.position.z));
        targetMat.color.setHex(d < 1.0 ? 0x00ff00 : 0x008800);
        targetMat.opacity = d < 1.0 ? 0.8 : 0.5;
      }

      controls.update();

      renderer.setViewport(0, 0, window.innerWidth, window.innerHeight);
      renderer.setScissor(0, 0, window.innerWidth, window.innerHeight);
      renderer.setScissorTest(true);
      renderer.clear();
      renderer.render(scene, camera);

      const pipWidth = 320, pipHeight = 240;
      const pipLeft = window.innerWidth - pipWidth - 20;
      const pipBottom = 20;
      renderer.setViewport(pipLeft, pipBottom, pipWidth, pipHeight);
      renderer.setScissor(pipLeft, pipBottom, pipWidth, pipHeight);
      renderer.setScissorTest(true);
      renderer.render(scene, cameraJ5);
    }

    updateJoints();
    animate();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>

</html>
